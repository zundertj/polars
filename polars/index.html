<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Polars: DataFrames in Rust"><title>polars - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="polars" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (a266f1199 2023-03-22)" data-search-js="search-a6dd7f063a44c279.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../static.files/storage-9184409068f70b79.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f5a2577c5297a973.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../polars/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../polars/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate polars</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.27.2</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">polars</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/polars/lib.rs.html#1-395">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="polars-dataframes-in-rust"><a href="#polars-dataframes-in-rust">Polars: <em><small>DataFrames in Rust</small></em></a></h2>
<p>Polars is a DataFrame library for Rust. It is based on <a href="https://arrow.apache.org/">Apache Arrow</a>’s memory model.
Apache arrow provides very cache efficient columnar data structures and is becoming the defacto
standard for columnar data.</p>
<h3 id="quickstart"><a href="#quickstart">Quickstart</a></h3>
<p>We recommend to build your queries directly with polars-lazy. This allows you to combine
expression into powerful aggregations and column selections. All expressions are evaluated
in parallel and your queries are optimized just in time.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>polars::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>lf1 = LazyFrame::scan_parquet(<span class="string">&quot;myfile_1.parquet&quot;</span>, Default::default())<span class="question-mark">?
    </span>.groupby([col(<span class="string">&quot;ham&quot;</span>)])
    .agg([
        <span class="comment">// expressions can be combined into powerful aggregations
        </span>col(<span class="string">&quot;foo&quot;</span>)
            .sort_by([col(<span class="string">&quot;ham&quot;</span>).rank(Default::default())], [<span class="bool-val">false</span>])
            .last()
            .alias(<span class="string">&quot;last_foo_ranked_by_ham&quot;</span>),
        <span class="comment">// every expression runs in parallel
        </span>col(<span class="string">&quot;foo&quot;</span>).cummin(<span class="bool-val">false</span>).alias(<span class="string">&quot;cumulative_min_per_group&quot;</span>),
        <span class="comment">// every expression runs in parallel
        </span>col(<span class="string">&quot;foo&quot;</span>).reverse().list().alias(<span class="string">&quot;reverse_group&quot;</span>),
    ]);

<span class="kw">let </span>lf2 = LazyFrame::scan_parquet(<span class="string">&quot;myfile_2.parquet&quot;</span>, Default::default())<span class="question-mark">?
    </span>.select([col(<span class="string">&quot;ham&quot;</span>), col(<span class="string">&quot;spam&quot;</span>)]);

<span class="kw">let </span>df = lf1
    .join(lf2, [col(<span class="string">&quot;reverse&quot;</span>)], [col(<span class="string">&quot;foo&quot;</span>)], JoinType::Left)
    <span class="comment">// now we finally materialize the result.
    </span>.collect()<span class="question-mark">?</span>;</code></pre></div>
<p>This means that Polars data structures can be shared zero copy with processes in many different
languages.</p>
<h3 id="tree-of-contents"><a href="#tree-of-contents">Tree Of Contents</a></h3>
<ul>
<li><a href="#cookbooks">Cookbooks</a></li>
<li><a href="#data-structures">Data structures</a>
<ul>
<li><a href="#dataframe">DataFrame</a></li>
<li><a href="#series">Series</a></li>
<li><a href="#chunkedarray">ChunkedArray</a></li>
</ul>
</li>
<li><a href="#simd">SIMD</a></li>
<li><a href="#api">API</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#compile-times">Compile times</a></li>
<li><a href="#performance-and-string-data">Performance</a>
<ul>
<li><a href="#custom-allocator">Custom allocator</a></li>
</ul>
</li>
<li><a href="#config-with-env-vars">Config</a></li>
<li><a href="#user-guide">User Guide</a></li>
</ul>
<h3 id="cookbooks"><a href="#cookbooks">Cookbooks</a></h3>
<p>See examples in the cookbooks:</p>
<ul>
<li><a href="docs/eager/index.html" title="mod polars::docs::eager">Eager</a></li>
<li><a href="docs/lazy/index.html" title="mod polars::docs::lazy">Lazy</a></li>
</ul>
<h3 id="data-structures"><a href="#data-structures">Data Structures</a></h3>
<p>The base data structures provided by polars are <code>DataFrame</code>, <code>Series</code>, and <code>ChunkedArray&lt;T&gt;</code>.
We will provide a short, top-down view of these data structures.</p>
<h4 id="dataframe"><a href="#dataframe">DataFrame</a></h4>
<p>A <code>DataFrame</code> is a 2 dimensional data structure that is backed by a <code>Series</code>, and it could be
seen as an abstraction on <code>Vec&lt;Series&gt;</code>. Operations that can be executed on <code>DataFrame</code>s are very
similar to what is done in a <code>SQL</code> like query. You can <code>GROUP</code>, <code>JOIN</code>, <code>PIVOT</code> etc.</p>
<h4 id="series"><a href="#series">Series</a></h4>
<p><code>Series</code> are the type agnostic columnar data representation of Polars. They provide many
operations out of the box, many via the <a href="series/struct.Series.html" title="struct polars::series::Series">Series struct</a> and
<a href="series/trait.SeriesTrait.html" title="trait polars::series::SeriesTrait">SeriesTrait trait</a>. Whether or not an operation is provided
by a <code>Series</code> is determined by the operation. If the operation can be done without knowing the
underlying columnar type, this operation probably is provided by the <code>Series</code>. If not, you must
downcast to the typed data structure that is wrapped by the <code>Series</code>. That is the <code>ChunkedArray&lt;T&gt;</code>.</p>
<h4 id="chunkedarray"><a href="#chunkedarray">ChunkedArray</a></h4>
<p><code>ChunkedArray&lt;T&gt;</code> are wrappers around an arrow array, that can contain multiples chunks, e.g.
<code>Vec&lt;dyn ArrowArray&gt;</code>. These are the root data structures of Polars, and implement many operations.
Most operations are implemented by traits defined in <a href="chunked_array/ops/index.html" title="mod polars::chunked_array::ops">chunked_array::ops</a>,
or on the <a href="chunked_array/struct.ChunkedArray.html" title="struct polars::chunked_array::ChunkedArray">ChunkedArray struct</a>.</p>
<h3 id="simd"><a href="#simd">SIMD</a></h3>
<p>Polars / Arrow uses packed_simd to speed up kernels with SIMD operations. SIMD is an optional
<code>feature = &quot;nightly&quot;</code>, and requires a nightly compiler. If you don’t need SIMD, <strong>Polars runs on stable!</strong></p>
<h3 id="api"><a href="#api">API</a></h3>
<p>Polars supports an eager and a lazy API. The eager API directly yields results, but is overall
more verbose and less capable of building elegant composite queries. We recommend to use the Lazy API
whenever you can.</p>
<p>As neither API is async they should be wrapped in <code>spawn_blocking</code> when used in an async context
to avoid blocking the async thread pool of the runtime.</p>
<h3 id="expressions"><a href="#expressions">Expressions</a></h3>
<p>Polars has a powerful concept called expressions.
Polars expressions can be used in various contexts and are a functional mapping of
<code>Fn(Series) -&gt; Series</code>, meaning that they have Series as input and Series as output.
By looking at this functional definition, we can see that the output of an <code>Expr</code> also can serve
as the input of an <code>Expr</code>.</p>
<p>That may sound a bit strange, so lets give an example. The following is an expression:</p>
<p><code>col(&quot;foo&quot;).sort().head(2)</code></p>
<p>The snippet above says select column <code>&quot;foo&quot;</code> then sort this column and then take first 2 values
of the sorted output.
The power of expressions is that every expression produces a new expression and that they can
be piped together.
You can run an expression by passing them on one of polars execution contexts.
Here we run two expressions in the <strong>select</strong> context:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  df.lazy()
   .select([
       col(<span class="string">&quot;foo&quot;</span>).sort(Default::default()).head(<span class="prelude-val">None</span>),
       col(<span class="string">&quot;bar&quot;</span>).filter(col(<span class="string">&quot;foo&quot;</span>).eq(lit(<span class="number">1</span>))).sum(),
   ])
   .collect()<span class="question-mark">?</span>;</code></pre></div>
<p>All expressions are ran in parallel, meaning that separate polars expressions are embarrassingly parallel.
(Note that within an expression there may be more parallelization going on).</p>
<p>Understanding polars expressions is most important when starting with the polars library. Read more
about them in the <a href="https://pola-rs.github.io/polars-book/user-guide/dsl/intro.html">User Guide</a>.
Though the examples given there are in python. The expressions API is almost identical and the
the read should certainly be valuable to rust users as well.</p>
<h4 id="eager"><a href="#eager">Eager</a></h4>
<p>Read more in the pages of the following data structures /traits.</p>
<ul>
<li><a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame">DataFrame struct</a></li>
<li><a href="series/struct.Series.html" title="struct polars::series::Series">Series struct</a></li>
<li><a href="series/trait.SeriesTrait.html" title="trait polars::series::SeriesTrait">Series trait</a></li>
<li><a href="chunked_array/struct.ChunkedArray.html" title="struct polars::chunked_array::ChunkedArray">ChunkedArray struct</a></li>
<li><a href="chunked_array/ops/index.html" title="mod polars::chunked_array::ops">ChunkedArray operations traits</a></li>
</ul>
<h4 id="lazy"><a href="#lazy">Lazy</a></h4>
<p>Unlock full potential with lazy computation. This allows query optimizations and provides Polars
the full query context so that the fastest algorithm can be chosen.</p>
<p><strong><a href="../polars_lazy/index.html" title="mod polars_lazy">Read more in the lazy module.</a></strong></p>
<h3 id="compile-times"><a href="#compile-times">Compile times</a></h3>
<p>A DataFrame library typically consists of</p>
<ul>
<li>Tons of features</li>
<li>A lot of datatypes</li>
</ul>
<p>Both of these really put strain on compile times. To keep Polars lean, we make both <strong>opt-in</strong>,
meaning that you only pay the compilation cost, if you need it.</p>
<h3 id="compile-times-and-opt-in-features"><a href="#compile-times-and-opt-in-features">Compile times and opt-in features</a></h3>
<p>The opt-in features are (not including dtype features):</p>
<ul>
<li>
<p><code>performant</code> - Longer compile times more fast paths.</p>
</li>
<li>
<p><code>lazy</code> - Lazy API</p>
<ul>
<li><code>lazy_regex</code> - Use regexes in <a href="prelude/fn.col.html" title="fn polars::prelude::col">column selection</a></li>
<li><code>dot_diagram</code> - Create dot diagrams from lazy logical plans.</li>
</ul>
</li>
<li>
<p><code>sql</code> - Pass SQL queries to polars.</p>
</li>
<li>
<p><code>streaming</code> - Be able to process datasets that are larger than RAM.</p>
</li>
<li>
<p><code>random</code> - Generate arrays with randomly sampled values</p>
</li>
<li>
<p><code>ndarray</code>- Convert from <code>DataFrame</code> to <code>ndarray</code></p>
</li>
<li>
<p><code>temporal</code> - Conversions between <a href="https://docs.rs/chrono/">Chrono</a> and Polars for temporal data types</p>
</li>
<li>
<p><code>timezones</code> - Activate timezone support.</p>
</li>
<li>
<p><code>strings</code> - Extra string utilities for <code>Utf8Chunked</code></p>
<ul>
<li><code>string_justify</code> - <code>zfill</code>, <code>ljust</code>, <code>rjust</code></li>
<li><code>string_from_radix</code> - <code>parse_int</code></li>
</ul>
</li>
<li>
<p><code>object</code> - Support for generic ChunkedArrays called <code>ObjectChunked&lt;T&gt;</code> (generic over <code>T</code>).
These are downcastable from Series through the <a href="https://doc.rust-lang.org/std/any/index.html">Any</a> trait.</p>
</li>
<li>
<p>Performance related:</p>
<ul>
<li><code>nightly</code> - Several nightly only features such as SIMD and specialization.</li>
<li><code>performant</code> - more fast paths, slower compile times.</li>
<li><code>bigidx</code> - Activate this feature if you expect &gt;&gt; 2^32 rows. This has not been needed by anyone.
This allows polars to scale up way beyond that by using <code>u64</code> as an index.
Polars will be a bit slower with this feature activated as many data structures
are less cache efficient.</li>
<li><code>cse</code> - Activate common subplan elimination optimization</li>
</ul>
</li>
<li>
<p>IO related:</p>
<ul>
<li><code>serde</code> - Support for <a href="https://crates.io/crates/serde">serde</a> serialization and deserialization.
Can be used for JSON and more serde supported serialization formats.</li>
<li><code>serde-lazy</code> - Support for <a href="https://crates.io/crates/serde">serde</a> serialization and deserialization.
Can be used for JSON and more serde supported serialization formats.</li>
<li><code>parquet</code> - Read Apache Parquet format</li>
<li><code>json</code> - JSON serialization</li>
<li><code>ipc</code> - Arrow’s IPC format serialization</li>
<li><code>decompress</code> - Automatically infer compression of csv-files and decompress them.
Supported compressions:
* zip
* gzip</li>
</ul>
</li>
<li>
<p><code>DataFrame</code> operations:</p>
<ul>
<li><code>dynamic_groupby</code> - Groupby based on a time window instead of predefined keys.
Also activates rolling window group by operations.</li>
<li><code>sort_multiple</code> - Allow sorting a <code>DataFrame</code> on multiple columns</li>
<li><code>rows</code> - Create <code>DataFrame</code> from rows and extract rows from <code>DataFrames</code>.
And activates <code>pivot</code> and <code>transpose</code> operations</li>
<li><code>asof_join</code> - Join ASOF, to join on nearest keys instead of exact equality match.</li>
<li><code>cross_join</code> - Create the cartesian product of two DataFrames.</li>
<li><code>semi_anti_join</code> - SEMI and ANTI joins.</li>
<li><code>groupby_list</code> - Allow groupby operation on keys of type List.</li>
<li><code>row_hash</code> - Utility to hash DataFrame rows to UInt64Chunked</li>
<li><code>diagonal_concat</code> - Concat diagonally thereby combining different schemas.</li>
<li><code>horizontal_concat</code> - Concat horizontally and extend with null values if lengths don’t match</li>
<li><code>dataframe_arithmetic</code> - Arithmetic on (Dataframe and DataFrames) and (DataFrame on Series)</li>
<li><code>partition_by</code> - Split into multiple DataFrames partitioned by groups.</li>
</ul>
</li>
<li>
<p><code>Series</code>/<code>Expression</code> operations:</p>
<ul>
<li><code>is_in</code> - <a href="chunked_array/object/trait.IsIn.html" title="trait polars::chunked_array::object::IsIn">Check for membership in <code>Series</code></a></li>
<li><code>zip_with</code> - <a href="chunked_array/object/trait.ChunkZip.html" title="trait polars::chunked_array::object::ChunkZip">Zip two Series/ ChunkedArrays</a></li>
<li><code>round_series</code> - round underlying float types of <code>Series</code>.</li>
<li><code>repeat_by</code> - [Repeat element in an Array N times, where N is given by another array.</li>
<li><code>is_first</code> - Check if element is first unique value.</li>
<li><code>is_last</code> - Check if element is last unique value.</li>
<li><code>checked_arithmetic</code> - checked arithmetic/ returning <code>None</code> on invalid operations.</li>
<li><code>dot_product</code> - Dot/inner product on Series and Expressions.</li>
<li><code>concat_str</code> - Concat string data in linear time.</li>
<li><code>reinterpret</code> - Utility to reinterpret bits to signed/unsigned</li>
<li><code>take_opt_iter</code> - Take from a Series with <code>Iterator&lt;Item=Option&lt;usize&gt;&gt;</code></li>
<li><code>mode</code> - <a href="chunked_array/object/trait.ChunkUnique.html#method.mode" title="method polars::chunked_array::object::ChunkUnique::mode">Return the most occurring value(s)</a></li>
<li><code>cum_agg</code> - cumsum, cummin, cummax aggregation.</li>
<li><code>rolling_window</code> - rolling window functions, like rolling_mean</li>
<li><code>interpolate</code> <a href="crate::chunked_array::ops::Interpolate">interpolate None values</a></li>
<li><code>extract_jsonpath</code> - <a href="https://goessner.net/articles/JsonPath/">Run jsonpath queries on Utf8Chunked</a></li>
<li><code>list</code> - List utils.
<ul>
<li><code>list_take</code> take sublist by multiple indices</li>
</ul>
</li>
<li><code>rank</code> - Ranking algorithms.</li>
<li><code>moment</code> - kurtosis and skew statistics</li>
<li><code>ewma</code> - Exponential moving average windows</li>
<li><code>abs</code> - Get absolute values of Series</li>
<li><code>arange</code> - Range operation on Series</li>
<li><code>product</code> - Compute the product of a Series.</li>
<li><code>diff</code> - <code>diff</code> operation.</li>
<li><code>pct_change</code> - Compute change percentages.</li>
<li><code>unique_counts</code> - Count unique values in expressions.</li>
<li><code>log</code> - Logarithms for <code>Series</code>.</li>
<li><code>list_to_struct</code> - Convert <code>List</code> to <code>Struct</code> dtypes.</li>
<li><code>list_count</code> - Count elements in lists.</li>
<li><code>list_eval</code> - Apply expressions over list elements.</li>
<li><code>cumulative_eval</code> - Apply expressions over cumulatively increasing windows.</li>
<li><code>arg_where</code> - Get indices where condition holds.</li>
<li><code>search_sorted</code> - Find indices where elements should be inserted to maintain order.</li>
<li><code>date_offset</code> Add an offset to dates that take months and leap years into account.</li>
<li><code>trigonometry</code> Trigonometric functions.</li>
<li><code>sign</code> Compute the element-wise sign of a Series.</li>
<li><code>propagate_nans</code> NaN propagating min/max aggregations.</li>
</ul>
</li>
<li>
<p><code>DataFrame</code> pretty printing</p>
<ul>
<li><code>fmt</code> - Activate DataFrame formatting</li>
</ul>
</li>
</ul>
<h3 id="compile-times-and-opt-in-data-types"><a href="#compile-times-and-opt-in-data-types">Compile times and opt-in data types</a></h3>
<p>As mentioned above, Polars <code>Series</code> are wrappers around
<code>ChunkedArray&lt;T&gt;</code> without the generic parameter <code>T</code>.
To get rid of the generic parameter, all the possible value of <code>T</code> are compiled
for <code>Series</code>. This gets more expensive the more types you want for a <code>Series</code>. In order to reduce
the compile times, we have decided to default to a minimal set of types and make more <code>Series</code> types
opt-in.</p>
<p>Note that if you get strange compile time errors, you probably need to opt-in for that <code>Series</code> dtype.
The opt-in dtypes are:</p>
<div><table><thead><tr><th>data type</th><th>feature flag</th></tr></thead><tbody>
<tr><td>Date</td><td>dtype-date</td></tr>
<tr><td>Datetime</td><td>dtype-datetime</td></tr>
<tr><td>Time</td><td>dtype-time</td></tr>
<tr><td>Duration</td><td>dtype-duration</td></tr>
<tr><td>Int8</td><td>dtype-i8</td></tr>
<tr><td>Int16</td><td>dtype-i16</td></tr>
<tr><td>UInt8</td><td>dtype-u8</td></tr>
<tr><td>UInt16</td><td>dtype-u16</td></tr>
<tr><td>Categorical</td><td>dtype-categorical</td></tr>
<tr><td>Struct</td><td>dtype-struct</td></tr>
</tbody></table>
</div>
<p>Or you can choose on of the preconfigured pre-sets.</p>
<ul>
<li><code>dtype-full</code> - all opt-in dtypes.</li>
<li><code>dtype-slim</code> - slim preset of opt-in dtypes.</li>
</ul>
<h3 id="performance-and-string-data"><a href="#performance-and-string-data">Performance and string data</a></h3>
<p>Large string data can really slow down your queries.
Read more in the <a href="docs/performance/index.html" title="mod polars::docs::performance">performance section</a></p>
<h4 id="custom-allocator"><a href="#custom-allocator">Custom allocator</a></h4>
<p>A DataFrame library naturally does a lot of heap allocations. It is recommended to use a custom
allocator.
<a href="https://crates.io/crates/mimalloc">Mimalloc</a> and
<a href="https://crates.io/crates/jemallocator">JeMalloc</a> for instance, show a significant
performance gain in runtime as well as memory usage.</p>
<h5 id="usage"><a href="#usage">Usage</a></h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mimalloc::MiMalloc;

<span class="attr">#[global_allocator]
</span><span class="kw">static </span>GLOBAL: MiMalloc = MiMalloc;</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jemallocator::Jemalloc;

<span class="attr">#[global_allocator]
</span><span class="kw">static </span>GLOBAL: Jemalloc = Jemalloc;</code></pre></div>
<h5 id="notes"><a href="#notes">Notes</a></h5>
<p><a href="https://github.com/pola-rs/polars/pull/3108">Benchmarks</a> have shown that on Linux JeMalloc
outperforms Mimalloc on all tasks and is therefor the default Linux allocator used for the Python bindings.</p>
<h5 id="cargotoml"><a href="#cargotoml">Cargo.toml</a></h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>[dependencies]
mimalloc = { version = <span class="string">&quot;*&quot;</span>, default-features = <span class="bool-val">false </span>}</code></pre></div>
<h3 id="config-with-env-vars"><a href="#config-with-env-vars">Config with ENV vars</a></h3>
<ul>
<li>
<p><code>POLARS_FMT_TABLE_FORMATTING</code> -&gt; define styling of tables using any of the following options (default = UTF8_FULL_CONDENSED):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>                             ASCII_FULL
                             ASCII_FULL_CONDENSED
                             ASCII_NO_BORDERS
                             ASCII_BORDERS_ONLY
                             ASCII_BORDERS_ONLY_CONDENSED
                             ASCII_HORIZONTAL_ONLY
                             ASCII_MARKDOWN
                             UTF8_FULL
                             UTF8_FULL_CONDENSED
                             UTF8_NO_BORDERS
                             UTF8_BORDERS_ONLY
                             UTF8_HORIZONTAL_ONLY
                             NOTHING
                               
                             These options are defined by comfy-table which provides examples <span class="kw">for </span>each at:
                             https:<span class="comment">//github.com/Nukesor/comfy-table/blob/main/src/style/presets.rs</span></code></pre></div>
</li>
<li>
<p><code>POLARS_FMT_TABLE_CELL_ALIGNMENT</code> -&gt; define cell alignment using any of the following options (default = LEFT):
LEFT
CENTER
RIGHT</p>
</li>
<li>
<p><code>POLARS_FMT_TABLE_DATAFRAME_SHAPE_BELOW</code> -&gt; print shape information below the table.</p>
</li>
<li>
<p><code>POLARS_FMT_TABLE_HIDE_COLUMN_NAMES</code> -&gt; hide table column names.</p>
</li>
<li>
<p><code>POLARS_FMT_TABLE_HIDE_COLUMN_DATA_TYPES</code> -&gt; hide data types for columns.</p>
</li>
<li>
<p><code>POLARS_FMT_TABLE_HIDE_COLUMN_SEPARATOR</code> -&gt; hide separator that separates column names from rows.</p>
</li>
<li>
<p><code>POLARS_FMT_TABLE_HIDE_DATAFRAME_SHAPE_INFORMATION&quot;</code> -&gt; omit table shape information.</p>
</li>
<li>
<p><code>POLARS_FMT_TABLE_INLINE_COLUMN_DATA_TYPE</code> -&gt; put column data type on the same line as the column name.</p>
</li>
<li>
<p><code>POLARS_FMT_TABLE_ROUNDED_CORNERS</code> -&gt; apply rounded corners to UTF8-styled tables.</p>
</li>
<li>
<p><code>POLARS_FMT_MAX_COLS</code> -&gt; maximum number of columns shown when formatting DataFrames.</p>
</li>
<li>
<p><code>POLARS_FMT_MAX_ROWS</code> -&gt; maximum number of rows shown when formatting DataFrames.</p>
</li>
<li>
<p><code>POLARS_FMT_STR_LEN</code> -&gt; maximum number of characters printed per string value.</p>
</li>
<li>
<p><code>POLARS_TABLE_WIDTH</code> -&gt; width of the tables used during DataFrame formatting.</p>
</li>
<li>
<p><code>POLARS_MAX_THREADS</code> -&gt; maximum number of threads used to initialize thread pool (on startup).</p>
</li>
<li>
<p><code>POLARS_VERBOSE</code> -&gt; print logging info to stderr.</p>
</li>
<li>
<p><code>POLARS_NO_PARTITION</code> -&gt; polars may choose to partition the groupby operation, based on data
cardinality. Setting this env var will turn partitioned groupby’s off.</p>
</li>
<li>
<p><code>POLARS_PARTITION_SAMPLE_FRAC</code> -&gt; how large chunk of the dataset to sample to determine cardinality,
defaults to <code>0.001</code>.</p>
</li>
<li>
<p><code>POLARS_PARTITION_UNIQUE_COUNT</code> -&gt; at which (estimated) key count a partitioned groupby should run.
defaults to <code>1000</code>, any higher cardinality will run default groupby.</p>
</li>
<li>
<p><code>POLARS_FORCE_PARTITION</code> -&gt; force partitioned groupby if the keys and aggregations allow it.</p>
</li>
<li>
<p><code>POLARS_ALLOW_EXTENSION</code> -&gt; allows for <code>[ObjectChunked&lt;T&gt;]</code> to be used in arrow, opening up possibilities like using
<code>T</code> in complex lazy expressions. However this does require <code>unsafe</code> code allow this.</p>
</li>
<li>
<p><code>POLARS_NO_PARQUET_STATISTICS</code> -&gt; if set, statistics in parquet files are ignored.</p>
</li>
<li>
<p><code>POLARS_PANIC_ON_ERR</code> -&gt; panic instead of returning an Error.</p>
</li>
<li>
<p><code>POLARS_NO_CHUNKED_JOIN</code> -&gt; force rechunk before joins.</p>
</li>
</ul>
<h3 id="user-guide"><a href="#user-guide">User Guide</a></h3>
<p>If you want to read more, <a href="https://pola-rs.github.io/polars-book/">check the User Guide</a>.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.io"><code>pub use <a class="mod" href="../polars_io/index.html" title="mod polars_io">polars_io</a> as io;</code></div></li><li><div class="item-name" id="reexport.lazy"><code>pub use <a class="mod" href="../polars_lazy/index.html" title="mod polars_lazy">polars_lazy</a> as lazy;</code></div></li><li><div class="item-name" id="reexport.time"><code>pub use <a class="mod" href="../polars_time/index.html" title="mod polars_time">polars_time</a> as time;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="chunked_array/index.html" title="mod polars::chunked_array">chunked_array</a></div><div class="desc docblock-short">The typed heart of every Series column.</div></li><li><div class="item-name"><a class="mod" href="datatypes/index.html" title="mod polars::datatypes">datatypes</a></div><div class="desc docblock-short">Data types supported by Polars.</div></li><li><div class="item-name"><a class="mod" href="doc/index.html" title="mod polars::doc">doc</a><span class="stab portability" title="Available on crate feature `docs` only"><code>docs</code></span></div><div class="desc docblock-short">Other documentation</div></li><li><div class="item-name"><a class="mod" href="docs/index.html" title="mod polars::docs">docs</a></div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod polars::error">error</a></div></li><li><div class="item-name"><a class="mod" href="export/index.html" title="mod polars::export">export</a></div></li><li><div class="item-name"><a class="mod" href="frame/index.html" title="mod polars::frame">frame</a></div><div class="desc docblock-short">DataFrame module.</div></li><li><div class="item-name"><a class="mod" href="functions/index.html" title="mod polars::functions">functions</a></div><div class="desc docblock-short">Functions</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod polars::prelude">prelude</a></div></li><li><div class="item-name"><a class="mod" href="series/index.html" title="mod polars::series">series</a></div><div class="desc docblock-short">Type agnostic columnar data structure.</div></li><li><div class="item-name"><a class="mod" href="testing/index.html" title="mod polars::testing">testing</a></div><div class="desc docblock-short">Testing utilities.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.apply_method_all_arrow_series.html" title="macro polars::apply_method_all_arrow_series">apply_method_all_arrow_series</a></div></li><li><div class="item-name"><a class="macro" href="macro.df.html" title="macro polars::df">df</a></div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.toggle_string_cache.html" title="fn polars::toggle_string_cache">toggle_string_cache</a><span class="stab portability" title="Available on crate feature `dtype-categorical` only"><code>dtype-categorical</code></span></div><div class="desc docblock-short">Use a global string cache for the Categorical Types.</div></li><li><div class="item-name"><a class="fn" href="fn.using_string_cache.html" title="fn polars::using_string_cache">using_string_cache</a><span class="stab portability" title="Available on crate feature `dtype-categorical` only"><code>dtype-categorical</code></span></div><div class="desc docblock-short">Check if string cache is set.</div></li></ul></section></div></main></body></html>