<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Provides function multiversioning."><title>multiversion in multiversion - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-1def573a4779b29b.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-d59023bfa12059d2.css"><link rel="stylesheet" disabled href="../static.files/dark-1ca41bb1e10af075.css"><link rel="stylesheet" disabled href="../static.files/ayu-18b4181a2f3fb862.css"><script src="../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../multiversion/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../multiversion/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In multiversion</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Attribute Macro <a href="index.html">multiversion</a>::<wbr><a class="attr" href="#">multiversion</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/multiversion_macros/lib.rs.html#19-22">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[multiversion]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Provides function multiversioning.</p>
<p>Functions are selected in order, calling the first matching target.  The function tagged by the
attribute is the generic implementation that does not require any specific architecture or
features.</p>
<h2 id="helper-attributes"><a href="#helper-attributes">Helper attributes</a></h2>
<ul>
<li><code>#[clone]</code>
<ul>
<li>Clones the function for the specified target.</li>
<li>Arguments:
<ul>
<li><code>target</code>: the target specification of the clone</li>
</ul>
</li>
</ul>
</li>
<li><code>#[specialize]</code>
<ul>
<li>Specializes the function for the specified target with another function.</li>
<li>Arguments:
<ul>
<li><code>target</code>: the target specification of the specialization</li>
<li><code>fn</code>: path to the function specializing the tagged function</li>
<li><code>unsafe</code> (optional): indicates whether the specialization function is <code>unsafe</code>, but safe to
call for this target.
Functions tagged with the <a href="attr.target.html"><code>target</code></a> attribute must be <code>unsafe</code>, so marking <code>unsafe = true</code>
indicates that the safety contract is fulfilled and<code>function</code> is safe to call on the specified
target.  If <code>function</code> is unsafe for any other reason, remember to mark the tagged function
<code>unsafe</code> as well.</li>
</ul>
</li>
</ul>
</li>
<li><code>#[crate_path]</code>
<ul>
<li>Specifies the location of the multiversion crate (useful for re-exporting).</li>
<li>Arguments:
<ul>
<li><code>path</code>: the path to the multiversion crate</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="examples"><a href="#examples">Examples</a></h2><h3 id="cloning"><a href="#cloning">Cloning</a></h3>
<p>The following compiles <code>square</code> three times, once for each target and once for the generic
target.  Calling <code>square</code> selects the appropriate version at runtime.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>multiversion::multiversion;

<span class="attr">#[multiversion]
#[clone(target = <span class="string">&quot;[x86|x86_64]+avx&quot;</span>)]
#[clone(target = <span class="string">&quot;x86+sse&quot;</span>)]
</span><span class="kw">fn </span>square(x: <span class="kw-2">&amp;mut </span>[f32]) {
    <span class="kw">for </span>v <span class="kw">in </span>x {
        <span class="kw-2">*</span>v <span class="kw-2">*</span>= <span class="kw-2">*</span>v
    }
}</code></pre></div>
<h3 id="specialization"><a href="#specialization">Specialization</a></h3>
<p>This example creates a function <code>where_am_i</code> that prints the detected CPU feature.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>multiversion::multiversion;

<span class="kw">fn </span>where_am_i_avx() {
    <span class="macro">println!</span>(<span class="string">&quot;avx&quot;</span>);
}

<span class="kw">fn </span>where_am_i_sse() {
    <span class="macro">println!</span>(<span class="string">&quot;sse&quot;</span>);
}

<span class="kw">fn </span>where_am_i_neon() {
    <span class="macro">println!</span>(<span class="string">&quot;neon&quot;</span>);
}

<span class="attr">#[multiversion]
#[specialize(target = <span class="string">&quot;[x86|x86_64]+avx&quot;</span>, <span class="kw">fn  </span>= <span class="string">&quot;where_am_i_avx&quot;</span>)]
#[specialize(target = <span class="string">&quot;x86+sse&quot;</span>, <span class="kw">fn </span>= <span class="string">&quot;where_am_i_sse&quot;</span>)]
#[specialize(target = <span class="string">&quot;[arm|aarch64]+neon&quot;</span>, <span class="kw">fn </span>= <span class="string">&quot;where_am_i_neon&quot;</span>)]
</span><span class="kw">fn </span>where_am_i() {
    <span class="macro">println!</span>(<span class="string">&quot;generic&quot;</span>);
}
</code></pre></div>
<h3 id="making-target_feature-functions-safe"><a href="#making-target_feature-functions-safe">Making <code>target_feature</code> functions safe</a></h3>
<p>This example is the same as the above example, but calls <code>unsafe</code> specialized functions.  Note
that the <code>where_am_i</code> function is still safe, since we know we are only calling specialized
functions on supported CPUs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>multiversion::{multiversion, target};

<span class="attr">#[target(<span class="string">&quot;[x86|x86_64]+avx&quot;</span>)]
</span><span class="kw">unsafe fn </span>where_am_i_avx() {
    <span class="macro">println!</span>(<span class="string">&quot;avx&quot;</span>);
}

<span class="attr">#[target(<span class="string">&quot;x86+sse&quot;</span>)]
</span><span class="kw">unsafe fn </span>where_am_i_sse() {
    <span class="macro">println!</span>(<span class="string">&quot;sse&quot;</span>);
}

<span class="attr">#[target(<span class="string">&quot;[arm|aarch64]+neon&quot;</span>)]
</span><span class="kw">unsafe fn </span>where_am_i_neon() {
    <span class="macro">println!</span>(<span class="string">&quot;neon&quot;</span>);
}

<span class="attr">#[multiversion]
#[specialize(target = <span class="string">&quot;[x86|x86_64]+avx&quot;</span>, <span class="kw">fn </span>= <span class="string">&quot;where_am_i_avx&quot;</span>, <span class="kw">unsafe </span>= <span class="bool-val">true</span>)]
#[specialize(target = <span class="string">&quot;x86+sse&quot;</span>, <span class="kw">fn </span>= <span class="string">&quot;where_am_i_sse&quot;</span>, <span class="kw">unsafe </span>= <span class="bool-val">true</span>)]
#[specialize(target = <span class="string">&quot;[arm|aarch64]+neon&quot;</span>, <span class="kw">fn </span>= <span class="string">&quot;where_am_i_neon&quot;</span>)]
</span><span class="kw">fn </span>where_am_i() {
    <span class="macro">println!</span>(<span class="string">&quot;generic&quot;</span>);
}
</code></pre></div>
<h2 id="static-dispatching"><a href="#static-dispatching">Static dispatching</a></h2>
<p>The <a href="attr.multiversion.html"><code>multiversion</code></a> attribute allows functions called inside the function to be statically dispatched.
Additionally, functions created with this attribute can themselves be statically dispatched.
See <a href="index.html#static-dispatching">static dispatching</a> for more information.</p>
<h2 id="conditional-compilation"><a href="#conditional-compilation">Conditional compilation</a></h2>
<p>The <a href="attr.multiversion.html"><code>multiversion</code></a> attribute supports conditional compilation with the <code>#[target_cfg]</code> helper
attribute. See <a href="index.html#conditional-compilation">conditional compilation</a> for more information.</p>
<h2 id="function-name-mangling"><a href="#function-name-mangling">Function name mangling</a></h2>
<p>The functions created by this macro are mangled as <code>{ident}_{features}_version</code>, where <code>ident</code> is
the name of the multiversioned function, and <code>features</code> is either <code>default</code> (for the default
version with no features enabled) or the list of features, sorted alphabetically.  Dots (<code>.</code>)
in the feature names are removed.</p>
<p>The following creates two functions, <code>foo_avx_sse41_version</code> and <code>foo_default_version</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[multiversion::multiversion]
#[clone(target = <span class="string">&quot;[x86|x86_64]+sse4.1+avx&quot;</span>)]
</span><span class="kw">fn </span>foo() {}

<span class="attr">#[multiversion::target(<span class="string">&quot;[x86|x86_64]+sse4.1+avx&quot;</span>)]
</span><span class="kw">unsafe fn </span>call_foo_avx() {
    foo_avx_sse41_version();
}

<span class="kw">fn </span>call_foo_default() {
    foo_default_version();
}</code></pre></div>
<h2 id="implementation-details"><a href="#implementation-details">Implementation details</a></h2>
<p>The function version dispatcher consists of a function selector and an atomic function pointer.
Initially the function pointer will point to the function selector. On invocation, this selector
will then choose an implementation, store a pointer to it in the atomic function pointer for later
use and then pass on control to the chosen function. On subsequent calls, the chosen function
will be called without invoking the function selector.</p>
<p>Some comments on the benefits of this implementation:</p>
<ul>
<li>The function selector is only invoked once. Subsequent calls are reduced to an atomic load
and indirect function call (for non-generic, non-<code>async</code> functions). Generic and <code>async</code> functions
cannot be stored in the atomic function pointer, which may result in additional branches.</li>
<li>If called in multiple threads, there is no contention. It is possible for two threads to hit
the same function before function selection has completed, which results in each thread
invoking the function selector, but the atomic ensures that these are synchronized correctly.</li>
</ul>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="multiversion" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0-nightly (065852def 2023-02-13)" data-search-js="search-abe1d547ad11c273.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>