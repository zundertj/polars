<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Lazy API of Polars"><title>polars_lazy - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="polars_lazy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (a266f1199 2023-03-22)" data-search-js="search-a6dd7f063a44c279.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../static.files/storage-9184409068f70b79.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f5a2577c5297a973.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../polars_lazy/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../polars_lazy/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate polars_lazy</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.27.2</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">polars_lazy</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/polars_lazy/lib.rs.html#1-196">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Lazy API of Polars</p>
<p>The lazy api of Polars supports a subset of the eager api. Apart from the distributed compute,
it is very similar to <a href="https://spark.apache.org/">Apache Spark</a>. You write queries in a
domain specific language. These queries translate to a logical plan, which represent your query steps.
Before execution this logical plan is optimized and may change the order of operations if this will increase performance.
Or implicit type casts may be added such that execution of the query won’t lead to a type error (if it can be resolved).</p>
<h2 id="lazy-dsl"><a href="#lazy-dsl">Lazy DSL</a></h2>
<p>The lazy API of polars can be used as long we operation on one or multiple DataFrame(s) and
Series of the same length as the DataFrame. To get started we call the <a href="frame/trait.IntoLazy.html#tymethod.lazy" title="method polars_lazy::frame::IntoLazy::lazy">lazy</a>
method. This returns a <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame">LazyFrame</a> exposing the lazy API.</p>
<p>Lazy operations don’t execute until we call <a href="frame/struct.LazyFrame.html#method.collect" title="method polars_lazy::frame::LazyFrame::collect">collect</a>.
This allows polars to optimize/reorder the query which may lead to faster queries or less type errors.</p>
<p>The DSL is mostly defined by <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame">LazyFrame</a> for operations on DataFrames and
the <a href="dsl/enum.Expr.html" title="enum polars_lazy::dsl::Expr">Expr</a> and functions in the <a href="dsl/index.html" title="mod polars_lazy::dsl">dsl modules</a> that operate
on expressions.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3><h5 id="adding-a-new-column-to-a-lazy-dataframe"><a href="#adding-a-new-column-to-a-lazy-dataframe">Adding a new column to a lazy DataFrame</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df! </span>{
     <span class="string">&quot;column_a&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     <span class="comment">// Note the reverse here!!
     </span>.reverse()
     .with_column(
         <span class="comment">// always rename a new column
         </span>(col(<span class="string">&quot;column_a&quot;</span>) * lit(<span class="number">10</span>)).alias(<span class="string">&quot;new_column&quot;</span>)
     )
     .collect()
     .unwrap();

 <span class="macro">assert!</span>(new.column(<span class="string">&quot;new_column&quot;</span>)
     .unwrap()
     .series_equal(
         <span class="kw-2">&amp;</span>Series::new(<span class="string">&quot;new_column&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>])
     )
 );</code></pre></div>
<h5 id="modifying-a-column-based-on-some-predicate"><a href="#modifying-a-column-based-on-some-predicate">Modifying a column based on some predicate</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df! </span>{
     <span class="string">&quot;column_a&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     .with_column(
         <span class="comment">// value = 100 if x &lt; 3 else x
         </span>when(
             col(<span class="string">&quot;column_a&quot;</span>).lt(lit(<span class="number">3</span>))
         ).then(
             lit(<span class="number">100</span>)
         ).otherwise(
             col(<span class="string">&quot;column_a&quot;</span>)
         ).alias(<span class="string">&quot;new_column&quot;</span>)
     )
     .collect()
     .unwrap();

 <span class="macro">assert!</span>(new.column(<span class="string">&quot;new_column&quot;</span>)
     .unwrap()
     .series_equal(
         <span class="kw-2">&amp;</span>Series::new(<span class="string">&quot;new_column&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">100</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])
     )
 );</code></pre></div>
<h5 id="groupby--aggregations"><a href="#groupby--aggregations">Groupby + Aggregations</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_core::df;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_arrow::prelude::QuantileInterpolOptions;

 <span class="kw">fn </span>example() -&gt; PolarsResult&lt;DataFrame&gt; {
     <span class="kw">let </span>df = <span class="macro">df!</span>(
     <span class="string">&quot;date&quot; </span>=&gt; [<span class="string">&quot;2020-08-21&quot;</span>, <span class="string">&quot;2020-08-21&quot;</span>, <span class="string">&quot;2020-08-22&quot;</span>, <span class="string">&quot;2020-08-23&quot;</span>, <span class="string">&quot;2020-08-22&quot;</span>],
     <span class="string">&quot;temp&quot; </span>=&gt; [<span class="number">20</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>],
     <span class="string">&quot;rain&quot; </span>=&gt; [<span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.01</span>]
     )<span class="question-mark">?</span>;

     df.lazy()
     .groupby([col(<span class="string">&quot;date&quot;</span>)])
     .agg([
         col(<span class="string">&quot;rain&quot;</span>).min(),
         col(<span class="string">&quot;rain&quot;</span>).sum(),
         col(<span class="string">&quot;rain&quot;</span>).quantile(lit(<span class="number">0.5</span>), QuantileInterpolOptions::Nearest).alias(<span class="string">&quot;median_rain&quot;</span>),
     ])
     .sort(<span class="string">&quot;date&quot;</span>, Default::default())
     .collect()

 }</code></pre></div>
<h5 id="calling-any-function"><a href="#calling-any-function">Calling any function</a></h5>
<p>Below we lazily call a custom closure of type <code>Series =&gt; Result&lt;Series&gt;</code>. Because the closure
changes the type/variant of the Series we also define the return type. This is important because
due to the laziness the types should be known beforehand. Note that by applying these custom
functions you have access the the whole <strong>eager API</strong> of the Series/ChunkedArrays.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df! </span>{
     <span class="string">&quot;column_a&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     .with_column(
         col(<span class="string">&quot;column_a&quot;</span>)
         <span class="comment">// apply a custom closure Series =&gt; Result&lt;Series&gt;
         </span>.map(|_s| {
             <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(Series::new(<span class="string">&quot;&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">6.0f32</span>, <span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>])))
         },
         <span class="comment">// return type of the closure
         </span>GetOutput::from_type(DataType::Float64)).alias(<span class="string">&quot;new_column&quot;</span>)
     )
     .collect()
     .unwrap();</code></pre></div>
<h5 id="joins-filters-and-projections"><a href="#joins-filters-and-projections">Joins, filters and projections</a></h5>
<p>In the query below we do a lazy join and afterwards we filter rows based on the predicate <code>a &lt; 2</code>.
And last we select the columns <code>&quot;b&quot;</code> and <code>&quot;c_first&quot;</code>. In an eager API this query would be very
suboptimal because we join on DataFrames with more columns and rows than needed. In this case
the query optimizer will do the selection of the columns (projection) and the filtering of the
rows (selection) before the join, thereby reducing the amount of work done by the query.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn </span>example(df_a: DataFrame, df_b: DataFrame) -&gt; LazyFrame {
    df_a.lazy()
    .left_join(df_b.lazy(), col(<span class="string">&quot;b_left&quot;</span>), col(<span class="string">&quot;b_right&quot;</span>))
    .filter(
        col(<span class="string">&quot;a&quot;</span>).lt(lit(<span class="number">2</span>))
    )
    .groupby([col(<span class="string">&quot;b&quot;</span>)])
    .agg(
        <span class="macro">vec!</span>[col(<span class="string">&quot;b&quot;</span>).first(), col(<span class="string">&quot;c&quot;</span>).first()]
     )
    .select(<span class="kw-2">&amp;</span>[col(<span class="string">&quot;b&quot;</span>), col(<span class="string">&quot;c_first&quot;</span>)])
}</code></pre></div>
<p>If we want to do an aggregation on all columns we can use the wildcard operator <code>*</code> to achieve this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn </span>aggregate_all_columns(df_a: DataFrame) -&gt; LazyFrame {
    df_a.lazy()
    .groupby([col(<span class="string">&quot;b&quot;</span>)])
    .agg(
        <span class="macro">vec!</span>[col(<span class="string">&quot;*&quot;</span>).first()]
     )
}</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="dsl/index.html" title="mod polars_lazy::dsl">dsl</a></div><div class="desc docblock-short">Domain specific language for the Lazy API. This DSL revolves around the <a href="dsl/enum.Expr.html" title="enum polars_lazy::dsl::Expr"><code>Expr</code></a> type, which represents an abstract
operaton on a DataFrame, such as mapping over a column, filtering, groupby, or aggregation.
In general, functions on <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a>s consume the LazyFrame and produce a new LazyFrame representing
the result of applying the function and passed expressions to the consumed LazyFrame.
At runtime, when <a href="frame/struct.LazyFrame.html#method.collect" title="method polars_lazy::frame::LazyFrame::collect"><code>LazyFrame::collect</code></a> is called, the expressions that comprise
the LazyFrame’s logical plan are materialized on the actual underlying Series.
For instance, <code>let expr = col(&quot;x&quot;).pow(lit(2)).alias(&quot;x2&quot;);</code> would produce an expression representing the abstract
operation of squaring the column <code>&quot;x&quot;</code> and naming the resulting column <code>&quot;x2&quot;</code>, and to apply this operation to a
LazyFrame, you’d use <code>let lazy_df = lazy_df.with_column(expr);</code>.
(Of course, a column named <code>&quot;x&quot;</code> must either exist in the original DataFrame or be produced by one of the preceding
operations on the LazyFrame.)</div></li><li><div class="item-name"><a class="mod" href="frame/index.html" title="mod polars_lazy::frame">frame</a></div><div class="desc docblock-short">Lazy variant of a <a href="../polars_core/frame/struct.DataFrame.html" title="struct polars_core::frame::DataFrame">DataFrame</a>.</div></li><li><div class="item-name"><a class="mod" href="physical_plan/index.html" title="mod polars_lazy::physical_plan">physical_plan</a></div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod polars_lazy::prelude">prelude</a></div></li><li><div class="item-name"><a class="mod" href="utils/index.html" title="mod polars_lazy::utils">utils</a></div></li></ul></section></div></main></body></html>