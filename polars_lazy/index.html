<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Lazy API of Polars"><title>polars_lazy - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-1def573a4779b29b.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-d59023bfa12059d2.css"><link rel="stylesheet" disabled href="../static.files/dark-1ca41bb1e10af075.css"><link rel="stylesheet" disabled href="../static.files/ayu-18b4181a2f3fb862.css"><script src="../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../polars_lazy/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../polars_lazy/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate polars_lazy</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.27.2</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">polars_lazy</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/polars_lazy/lib.rs.html#1-196">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Lazy API of Polars</p>
<p>The lazy api of Polars supports a subset of the eager api. Apart from the distributed compute,
it is very similar to <a href="https://spark.apache.org/">Apache Spark</a>. You write queries in a
domain specific language. These queries translate to a logical plan, which represent your query steps.
Before execution this logical plan is optimized and may change the order of operations if this will increase performance.
Or implicit type casts may be added such that execution of the query won’t lead to a type error (if it can be resolved).</p>
<h2 id="lazy-dsl"><a href="#lazy-dsl">Lazy DSL</a></h2>
<p>The lazy API of polars can be used as long we operation on one or multiple DataFrame(s) and
Series of the same length as the DataFrame. To get started we call the <a href="frame/trait.IntoLazy.html#tymethod.lazy">lazy</a>
method. This returns a <a href="frame/struct.LazyFrame.html">LazyFrame</a> exposing the lazy API.</p>
<p>Lazy operations don’t execute until we call <a href="frame/struct.LazyFrame.html#method.collect">collect</a>.
This allows polars to optimize/reorder the query which may lead to faster queries or less type errors.</p>
<p>The DSL is mostly defined by <a href="frame/struct.LazyFrame.html">LazyFrame</a> for operations on DataFrames and
the <a href="dsl/enum.Expr.html">Expr</a> and functions in the <a href="dsl/index.html">dsl modules</a> that operate
on expressions.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3><h5 id="adding-a-new-column-to-a-lazy-dataframe"><a href="#adding-a-new-column-to-a-lazy-dataframe">Adding a new column to a lazy DataFrame</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df! </span>{
     <span class="string">&quot;column_a&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     <span class="comment">// Note the reverse here!!
     </span>.reverse()
     .with_column(
         <span class="comment">// always rename a new column
         </span>(col(<span class="string">&quot;column_a&quot;</span>) * lit(<span class="number">10</span>)).alias(<span class="string">&quot;new_column&quot;</span>)
     )
     .collect()
     .unwrap();

 <span class="macro">assert!</span>(new.column(<span class="string">&quot;new_column&quot;</span>)
     .unwrap()
     .series_equal(
         <span class="kw-2">&amp;</span>Series::new(<span class="string">&quot;new_column&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>])
     )
 );</code></pre></div>
<h5 id="modifying-a-column-based-on-some-predicate"><a href="#modifying-a-column-based-on-some-predicate">Modifying a column based on some predicate</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df! </span>{
     <span class="string">&quot;column_a&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     .with_column(
         <span class="comment">// value = 100 if x &lt; 3 else x
         </span>when(
             col(<span class="string">&quot;column_a&quot;</span>).lt(lit(<span class="number">3</span>))
         ).then(
             lit(<span class="number">100</span>)
         ).otherwise(
             col(<span class="string">&quot;column_a&quot;</span>)
         ).alias(<span class="string">&quot;new_column&quot;</span>)
     )
     .collect()
     .unwrap();

 <span class="macro">assert!</span>(new.column(<span class="string">&quot;new_column&quot;</span>)
     .unwrap()
     .series_equal(
         <span class="kw-2">&amp;</span>Series::new(<span class="string">&quot;new_column&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">100</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])
     )
 );</code></pre></div>
<h5 id="groupby--aggregations"><a href="#groupby--aggregations">Groupby + Aggregations</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_core::df;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_arrow::prelude::QuantileInterpolOptions;

 <span class="kw">fn </span>example() -&gt; PolarsResult&lt;DataFrame&gt; {
     <span class="kw">let </span>df = <span class="macro">df!</span>(
     <span class="string">&quot;date&quot; </span>=&gt; [<span class="string">&quot;2020-08-21&quot;</span>, <span class="string">&quot;2020-08-21&quot;</span>, <span class="string">&quot;2020-08-22&quot;</span>, <span class="string">&quot;2020-08-23&quot;</span>, <span class="string">&quot;2020-08-22&quot;</span>],
     <span class="string">&quot;temp&quot; </span>=&gt; [<span class="number">20</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>],
     <span class="string">&quot;rain&quot; </span>=&gt; [<span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.01</span>]
     )<span class="question-mark">?</span>;

     df.lazy()
     .groupby([col(<span class="string">&quot;date&quot;</span>)])
     .agg([
         col(<span class="string">&quot;rain&quot;</span>).min(),
         col(<span class="string">&quot;rain&quot;</span>).sum(),
         col(<span class="string">&quot;rain&quot;</span>).quantile(lit(<span class="number">0.5</span>), QuantileInterpolOptions::Nearest).alias(<span class="string">&quot;median_rain&quot;</span>),
     ])
     .sort(<span class="string">&quot;date&quot;</span>, Default::default())
     .collect()

 }</code></pre></div>
<h5 id="calling-any-function"><a href="#calling-any-function">Calling any function</a></h5>
<p>Below we lazily call a custom closure of type <code>Series =&gt; Result&lt;Series&gt;</code>. Because the closure
changes the type/variant of the Series we also define the return type. This is important because
due to the laziness the types should be known beforehand. Note that by applying these custom
functions you have access the the whole <strong>eager API</strong> of the Series/ChunkedArrays.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df! </span>{
     <span class="string">&quot;column_a&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot; </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     .with_column(
         col(<span class="string">&quot;column_a&quot;</span>)
         <span class="comment">// apply a custom closure Series =&gt; Result&lt;Series&gt;
         </span>.map(|_s| {
             <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(Series::new(<span class="string">&quot;&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">6.0f32</span>, <span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>])))
         },
         <span class="comment">// return type of the closure
         </span>GetOutput::from_type(DataType::Float64)).alias(<span class="string">&quot;new_column&quot;</span>)
     )
     .collect()
     .unwrap();</code></pre></div>
<h5 id="joins-filters-and-projections"><a href="#joins-filters-and-projections">Joins, filters and projections</a></h5>
<p>In the query below we do a lazy join and afterwards we filter rows based on the predicate <code>a &lt; 2</code>.
And last we select the columns <code>&quot;b&quot;</code> and <code>&quot;c_first&quot;</code>. In an eager API this query would be very
suboptimal because we join on DataFrames with more columns and rows than needed. In this case
the query optimizer will do the selection of the columns (projection) and the filtering of the
rows (selection) before the join, thereby reducing the amount of work done by the query.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn </span>example(df_a: DataFrame, df_b: DataFrame) -&gt; LazyFrame {
    df_a.lazy()
    .left_join(df_b.lazy(), col(<span class="string">&quot;b_left&quot;</span>), col(<span class="string">&quot;b_right&quot;</span>))
    .filter(
        col(<span class="string">&quot;a&quot;</span>).lt(lit(<span class="number">2</span>))
    )
    .groupby([col(<span class="string">&quot;b&quot;</span>)])
    .agg(
        <span class="macro">vec!</span>[col(<span class="string">&quot;b&quot;</span>).first(), col(<span class="string">&quot;c&quot;</span>).first()]
     )
    .select(<span class="kw-2">&amp;</span>[col(<span class="string">&quot;b&quot;</span>), col(<span class="string">&quot;c_first&quot;</span>)])
}</code></pre></div>
<p>If we want to do an aggregation on all columns we can use the wildcard operator <code>*</code> to achieve this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn </span>aggregate_all_columns(df_a: DataFrame) -&gt; LazyFrame {
    df_a.lazy()
    .groupby([col(<span class="string">&quot;b&quot;</span>)])
    .agg(
        <span class="macro">vec!</span>[col(<span class="string">&quot;*&quot;</span>).first()]
     )
}</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left"><a class="mod" href="dsl/index.html" title="mod polars_lazy::dsl">dsl</a></div><div class="item-right docblock-short">Domain specific language for the Lazy api.</div></div><div class="item-row"><div class="item-left"><a class="mod" href="frame/index.html" title="mod polars_lazy::frame">frame</a></div><div class="item-right docblock-short">Lazy variant of a <a href="../polars_core/frame/struct.DataFrame.html">DataFrame</a>.</div></div><div class="item-row"><div class="item-left"><a class="mod" href="physical_plan/index.html" title="mod polars_lazy::physical_plan">physical_plan</a></div></div><div class="item-row"><div class="item-left"><a class="mod" href="prelude/index.html" title="mod polars_lazy::prelude">prelude</a></div></div><div class="item-row"><div class="item-left"><a class="mod" href="utils/index.html" title="mod polars_lazy::utils">utils</a></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="polars_lazy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0-nightly (065852def 2023-02-13)" data-search-js="search-abe1d547ad11c273.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>